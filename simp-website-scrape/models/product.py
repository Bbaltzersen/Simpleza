# models/product.py

import uuid
# Import Integer and VARCHAR for better type definitions
from sqlalchemy import Column, Numeric, Integer, TEXT, VARCHAR, DateTime
from sqlalchemy.dialects.postgresql import UUID
from .base import Base
import datetime # Ensure datetime is imported if using default timestamps

class Product(Base):
    __tablename__ = "products"

    # Primary Key - UUID generated by default, looks good
    product_id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)

    # Retailer's specific ID (e.g., from URL)
    # Changed from Numeric to Integer as it seems to be a whole number ID
    # Made non-nullable and unique, as it should identify the product at the retailer
    retail_id = Column(Integer, unique=True, index=True, nullable=False)

    # Optional field for linking to a source product if needed
    src_product_id = Column(UUID(as_uuid=True), nullable=True)

    # --- FIX: Made nullable=True ---
    # Scraper doesn't reliably get English names, allow NULL
    english_name = Column(TEXT, nullable=True)

    # Spanish name is reliably scraped, keep as TEXT and non-nullable
    spanish_name = Column(TEXT, nullable=False)

    # Amount associated with the measurement (e.g., 1 for kg/l/unit, 6 for 6-pack)
    # Kept as Numeric for potential fractions, non-nullable, default 1 seems reasonable
    amount = Column(Numeric(10, 2), nullable=False, default=1)

    # --- FIX: Made nullable=True ---
    # Represents typical weight of the 'amount' (e.g., avg weight of 1 watermelon)
    # Scraper doesn't reliably get this, allow NULL
    weight = Column(Numeric(10, 2), nullable=True)

    # Standard unit for price comparison ('kg', 'l', 'unit')
    # Changed to VARCHAR(10) as values are short, kept non-nullable
    measurement = Column(VARCHAR(10), nullable=False)

    # Optional: Add timestamps for tracking when product was created/updated
    # created_at = Column(DateTime(timezone=True), default=lambda: datetime.datetime.now(datetime.timezone.utc), nullable=False)
    # updated_at = Column(DateTime(timezone=True), default=lambda: datetime.datetime.now(datetime.timezone.utc), onupdate=lambda: datetime.datetime.now(datetime.timezone.utc), nullable=False)